{
    "contents" : "\nlibrary(shiny)\nlibrary(maps)\nlibrary(geosphere)\nrequire(xlsx) #only if excel file is to be read\nlibrary(RColorBrewer)\nrequire(scales)\nrequire(plyr)  \nlibrary(ggplot2)\nlibrary(sp)\nlibrary(rgeos)\nrequire(reshape2)\nrequire(maptools)\n\n#* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n#*     Server work now\n#* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nshinyServer(function(input, output) {\n  #* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  #*     Functions\n  #* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  #Converting full name of state/teritories to abbreviations\n  getAbbreviation <- function(x) {\n    if (x == \"Queensland\") return(\"QLD\")\n    string <- strsplit(x, \" \")[[1]]\n    if (length(string) == 1) {return(toupper(substring(string, 1,3)))} else\n      return(paste(toupper(substring(string, 1,1)), sep=\"\", collapse=\"\"))\n  }\n  #Select cities at random from a state/territory based on \n  # weighted probability\n  getRandomCity <- function(xstate = \"SA\", xnum=1) {\n    allCities <- places.au[places.au$state == xstate,]\n    allCities <- allCities[order(allCities$pop),] #sort\n    if (nrow(allCities) == 0) {return(data.frame(lon=rep(NA, xnum),\n                                                 lat=rep(NA, xnum),\n                                                 state=rep(\"XY\", xnum)))}\n    selection <- sample(c(1:nrow(allCities)), xnum, replace=TRUE, prob=allCities$pop)\n    return(allCities[selection,])\n  }\n  ##usage: \n  # getRandomCity(\"SA\", 4);\n  # gets 4 cities' lat long from South Australia\n  #randomizing rows of a dataframe based on a grouping value\n  shuffelRows <- function(xdf, xcol){\n    v <- unique(xdf[,xcol])\n    x <- sample(v, size=length(v), replace=FALSE)\n    u <- merge(data.frame(xid = x), xdf, by.x = \"xid\",\n               by.y = names(xdf[xcol]), all.y = TRUE)\n    #   return(u[with(u, order(group, order)),])\n    return(u)\n  }\n  \n  #* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  #*     Read and prepare data\n  #* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  dataloc <- \"data/auInternal.xlsx\"\n  #\\\\Uofa\\users$\\users5\\a1634565\\data\n  aumig <- read.xlsx2(dataloc, 1, startRow = 4, endRow = 15, header=FALSE,\n                      colIndex = c(1:11),\n                      colClasses = c(\"character\", rep(\"numeric\", 10)))\n  #drop overseas, not stated and totals\n  aumig <- aumig[aumig$X1 != \"Overseas\" & aumig$X1 != \"Total\" & aumig$X1 != \"Not stated\",\n                 c(1:10)]\n  \n  aumig$X1 <- sapply(as.character(aumig$X1), getAbbreviation)\n  names(aumig) <- c(\"SOURCE\", aumig$X1)\n  #read au shapefile from gadm\n  aumap <- readShapeSpatial(\"data/AUS_adm/AUS_adm1.shp\")\n  aumap.df <- fortify(aumap)\n  places <- read.csv(\"data/cities1000.csv\", header=FALSE, stringsAsFactors=FALSE)\n  places <- places[places$V9 == \"AU\",]\n  #* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  #*     Data processing\n  #* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  #melt data\n  aumelt <- melt(aumig, c(\"SOURCE\"), names(aumig)[2:10],\n                 variable.name = \"DESTINATION\", value.name = \"MOVEMENT\")\n  #remove non movements\n  aumelt <- aumelt[aumelt$SOURCE != aumelt$DESTINATION, ]\n  aumelt <- aumelt[aumelt$MOVEMENT > 0,] #Remove 0 movement pattern\n  totmov <- sum(aumelt$MOVEMENT) #296983; seems individual lines possible ;)\n  aumelt$DESTINATION <- as.character(aumelt$DESTINATION)\n  aumelt$MOVEMENT <- round(aumelt$MOVEMENT/100,0)\n  #* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  #*     Get cities details\n  #* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n  places.df <- data.frame (as.numeric(places$V6), as.numeric(places$V5),\n                           places$V9, as.numeric(places$V15), places$V2)\n  #rm(places)\n  names(places.df) <- c('lon', \"lat\", \"code\", \"pop\", \"name\")\n  places.df <- places.df[,c(1:4)]\n  places.df <- places.df[complete.cases(places.df),]\n  places.bk <- places.df\n  # head(places.df)\n  coordinates(places.df) <- c(\"lon\", \"lat\")\n  proj4string(places.df) <- proj4string(aumap)\n  # inside <- !is.na(over(places.df, as(aumap.sa, \"SpatialPolygons\")))\n  places.df$state <- over(places.df, aumap)$NAME_1\n  # places.ff <- fortify.SpatialPointsDataFrame(places.df)\n  places.au <- data.frame(lon = places.df$lon,\n                          lat = places.df$lat,\n                          state = places.df$state,\n                          pop = places.df$pop)\n  places.au <- places.au[complete.cases(places.au),]\n  # head(places.au)\n  # unique(places.au$state)\n  places.au$state <- sapply(as.character(places.au$state),\n                            getAbbreviation)\n  nrow(places.au) #1072\n  #summarize places for each available country\n  cities.count <- ddply(places.au, c(\"state\"), function(xdf) {\n    return(data.frame(count = nrow(xdf)))\n  })\n  #inflate the table to include individual cases\n  aumelt$id <- c(1:nrow(aumelt))\n  aumelt.full <- ddply(aumelt, c(\"id\"), function(ydf) {\n    if (ydf$MOVEMENT == 1) {data <- ydf} else {\n      data <- ydf\n      for (i in 2: ydf$MOVEMENT) {\n        data <- rbind(data, ydf)\n      }\n      return(data)\n    }\n  })\n  # tail(m2013.final); head(m2013.final)\n  #m2013.final2 <- replaceCities(m2013.final)\n  #replace cities for loop\n  count <- nrow(aumelt.full)\n  head(aumelt.full); tail(aumelt.full)\n  aumelt.full <- aumelt.full[,c(-3, -4)]\n  aumelt.full <- aumelt.full[order(aumelt.full$SOURCE),]\n  str(aumelt.full)\n  source.replace <- ddply(aumelt.full, c(\"SOURCE\"), function(xdf) {\n    return(data.frame(getRandomCity(xdf$SOURCE[1], nrow(xdf))))\n  })\n  names(source.replace) <- c(\"source\", \"lon.s\", \"lat.s\", \"state\", \"pop\")\n  # nrow(source.replace) - nrow(aumelt.full) #should be 0 to work :)\n  aumelt.full <- cbind(aumelt.full,\n                       source.replace[,c(\"lon.s\", \"lat.s\")])\n  #sort according to destination\n  aumelt.full <- aumelt.full[order(aumelt.full$DESTINATION),] #sort\n  destination.replace <- ddply(aumelt.full, c(\"DESTINATION\"),\n                               function(xdf) {\n                                 return(data.frame(getRandomCity(xdf$DESTINATION[1], nrow(xdf))))\n                               })\n  names(destination.replace) <- c(\"destination\", \"lon.d\", \"lat.d\",\n                                  \"state\", \"pop\")\n  # nrow(destination.replace) - nrow(aumelt.full) #should be 0 to work :)\n  aumelt.full <- cbind(aumelt.full,\n                       destination.replace[,c(\"lon.d\", \"lat.d\")])\n  aumelt.full <- aumelt.full[complete.cases(aumelt.full),]\n  # aumelt.full <- aumelt.full[order(aumelt.full$pop),]\n  # head(aumelt.full)\n  \n  geosource <- matrix(c(aumelt.full$lon.s,\n                        aumelt.full$lat.s), ncol=2)\n  geodestination <- matrix(c(aumelt.full$lon.d,\n                             aumelt.full$lat.d), ncol=2)\n  arc.nombre <- 30\n  locdata <- data.frame(id = 1L:(length(geosource)/2),\n                        lons = geosource[,1],\n                        lats = geosource[,2],\n                        lond = geodestination[,1],\n                        latd = geodestination[,2])\n  t <- seq(0, 2*pi, length.out = arc.nombre + 2) #2 pi for sine curve\n  arc <- ddply(locdata, .(id), function(xdf) {\n    lonlist <- seq(xdf$lons, xdf$lond, length.out = arc.nombre + 2)\n    latlist <- seq(xdf$lats, xdf$latd, length.out = arc.nombre + 2)\n    d <- sqrt((xdf$lons - xdf$lond)^2 + (xdf$lats - xdf$latd)^2)\n    latlist <- latlist + (d/8) * sin(t)  #d/8 for sine curve\n    return(data.frame(long = lonlist,\n                      lat = latlist,\n                      order = 1L:(arc.nombre +2),\n                      piece = xdf$id,\n                      group = xdf$id))\n  })\n  arc$sort <- rep(sample(1:max(arc$piece)),\n                  each = arc.nombre + 2)\n  arc <- arc[order(arc$sort, arc$order), ]\n  row.names(arc) <- 1:nrow(arc)\n  \n#   output$myPanel <- renderUI({\n#     mystyle <- ifelse(is.null(input$colorid), \"ffffff\", input$colorid)\n#     inputPanel(\n#       numericInput('n', 'Number of obs', 100)\n#       , style = paste0(\"background-color:#\", mystyle, \";\")\n#     )\n#   })\n\n  #collect ui inputs\n  output$mapPlot <- renderPlot({\n    input$goButton\n    #bring in the junk here\n    #collect colours\n    couleur.source.default <- \"00ff00\"\n    couleur.destination.default <- \"ff0000\"\n    coluleur.mid.default <- \"0000ff\"\n    couleur.ocean.default <- \"00ff00\"\n    couleur.boundary.default <- \"ff0000\"\n    couleur.landmass.default <- \"0000ff\"\n    couleur.landmass <- isolate(ifelse(is.null(input$couleur_landmass),\n                               couleur.landmass.default,\n                               input$couleur_landmass))\n    input$goButton\n    couleur.boundary <- isolate(ifelse(is.null(input$couleur_boundary),\n                                       couleur.boundary.default,\n                                       input$couleur_boundary))\n    input$goButton\n    couleur.destination <- isolate(ifelse(is.null(input$couleur_destination),\n                                       couleur.destination.default,\n                                       input$couleur_destination))\n    input$goButton\n    couleur.source <- isolate(ifelse(is.null(input$couleur_source),\n                                          couleur.source.default,\n                                          input$couleur_source))\n    input$goButton\n    couleur.boundary <- isolate(ifelse(is.null(input$couleur_boundary),\n                                       couleur.boundary.default,\n                                       input$couleur_boundary))\n    input$goButton\n    couleur.mid <- isolate(ifelse(is.null(input$couleur_mid),\n                                       couleur.mid.default,\n                                       input$couleur_mid))\n    input$goButton\n    couleur.ocean <- isolate(ifelse(is.null(input$couleur_ocean),\n                                       couleur.ocean.default,\n                                       input$couleur_ocean))\n    alpha <- 0.04 #0.3 0.2\n    size <- 0.003 #0.02 0.01\n    \n    #end of junk\n    derpMap <- ggplot() +\n      geom_polygon(aes(long, lat, group=group), \n                   size = 0.05, colour = paste0(\"#\", couleur.boundary),\n                   fill = paste0(\"#\", couleur.landmass),\n                   data = aumap.df) +\n      geom_line(aes(long, lat, group = sort, col = order),\n                data = arc, alpha = 0.1, size = 0.05) + #drawing great circle lines works .02,.03\n      scale_colour_gradient2(high=paste0(\"#\", couleur.destination),\n                             low=paste0(\"#\", couleur.source),\n                             mid=paste0(\"#\", couleur.mid),\n                             midpoint=arc.nombre/2,\n                             name=\"Flow legend\",\n                             labels = c(\"Migrant origin\", \"Migrant destination\"),\n                             #breaks=seq(min(np.data$Total), max(np.data$Total), by=1000)\n                             breaks=c(1, arc.nombre),\n                             guide=\"legend\") +\n      xlim(112, 155) + ylim(-45, -7) + coord_equal() +\n#       guides(alpha = \"none\") +\n      theme(\n        plot.background = element_blank()\n        ,panel.grid.major = element_blank()\n        ,panel.grid.minor = element_blank()\n        ,panel.border = element_blank()\n#         ,panel.background = element_blank()\n        ,panel.background = element_rect(fill=paste0(\"#\", couleur.ocean),\n                                         colour=paste0(\"#\", couleur.ocean))\n        ,legend.position = \"none\"\n#         ,legend.title = element_text(size = 8, colour = text.couleur)\n        ,axis.text.x  = element_blank()\n        ,axis.text.y  = element_blank()\n        ,axis.ticks  = element_blank()\n        ,axis.title  = element_blank()\n        ,axis.title  = element_blank()\n      )\n    derpMap\n  })\n  \n})\n\n",
    "created" : 1415451697320.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1056952742",
    "id" : "FA71B1BB",
    "lastKnownWriteTime" : 1416662151,
    "path" : "C:/Users/Lenovo/github/shinymap/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}